#### 1. 垃圾回收机制

​	JS数据类型分为原始类型、引用类型，原始类型数据变量名和值都存在栈中，引用类型数据变量名存在栈中，值存在堆中。

​	临时数据：在内存中存在的时间很短，很快就会变得不可访问，如函数作用域或块级作用域中的临时变量

​	持久数据：在内存中存在的时间很长，如全局对象等

​	V8将堆内存分为新生代和老生代两个区域，新生代（小）存放临时数据，老生代存放持久数据，分别由两个垃圾回收器处理

​	新生代垃圾回收器：将新生代区域分为使用区和空闲区，新加入的对象会进入使用区，当使用区快满了就会开始进行垃圾回收，标记使用区中的活动对象，将其复制进空闲区后排序，然后清理使用区中的垃圾数据，最后将使用区和空闲区互换。当一个对象复制到空闲区且此时空闲区的内存占用超过25%，那这个对象会晋升到老生代区域，因为角色反转后如果空闲区内存占比太大，会影响后续的内存分配。

​	老生代垃圾回收器：使用标记清除算法，标记阶段从根对象出发遍历所有子属性，能访达的对象就是活动对象，其他就是垃圾数据；清除阶段就是直接将垃圾数据清理掉。多次标记清楚操作后，会出现大量不连续的内存碎片，需要进行内存整理。

#### 2. 进程和线程

##### 2.1 进程和线程的关系

```
> 进程之间相互隔离，一个进程崩溃不会影响其他进程
> 进程之间需要通过IPC（进程间通信）来通信
> 一个进程中可以有多个线程，每个线程并行执行不同的任务
> 一个进程中的任意一个线程崩溃，会导致这个进程崩溃
> 同一个进程下的线程之间，可以直接通信和共享数据
```

##### 2.2 Chrome浏览器进程

```
> 主（浏览器）进程：负责浏览器界面的显示，与用户交互，如地址栏、书签、前进后退刷新按钮，负责协调管理其他进程的工作
> GPU进程：负责渲染浏览器界面
> 网络进程：负责发起和接收网络请求，之前是浏览器进程中的一个模块，后面独立出来成为一个单独的进程
> 插件进程：负责插件的运行，由于插件可能会崩溃，所以需要为每个插件单独分配一个进程来隔离（每个插件各一个）
> 渲染（Renderer）进程：负责标签页内容的渲染（每个tab各一个），只在内存中生成栅格化的数据，不进行绘制，因为它不能在tab没有激活的情况下偷偷渲染页面
```

##### 2.3 渲染进程Renderer

```
渲染进程包含的线程：
> GUI渲染线程：负责页面的渲染，解析HTML、CSS，构建渲染树，布局（重排）、绘制（重绘），GUI渲染线程和JS引擎线程是互斥的，当JS引擎线程执行时，GUI渲染线程会被挂起，其更新任务会被保存到一个队列中，等到JS引擎线程空闲时会立即执行。
> JS引擎线程（内核）：负责解析运行JS代码，会一直等待着任务队列中的任务到来，然后执行，GUI渲染线程和JS引擎线程是互斥的，如果JS的执行时间过长，会导致页面的渲染卡顿。
> 事件触发线程：当JS引擎线程执行到如鼠标点击等事件时，会将任务添加到事件触发线程中，当任务符合触发条件时，该线程会把任务回调添加到事件队列，会开启事件循环机制，不断访问事件队列的头部，等待JS引擎线程空闲后，将队头任务推入执行栈中执行。
> 定时器线程：负责setTimout、setInterval的计时工作，到时间后会将回调放入事件队列中。
> 异步http请求线程：http连接后开启的线程，请求状态改变时，会将回调函数放入事件队列中。
```

##### 2.4 Web Worker

```
> Web Worker为JS提供在后台运行脚本的方法，创建Worker时，JS引擎线程向浏览器申请一个worker子线程（受浏览器进程控制且不能操作DOM），JS引擎线程通过PostMessage API与worker线程通信（参数需要序列化）。
> Web Worker只属于某个tab页，是一个线程，Shared Worker则可以被多个tab页共享，是一个进程。
```

##### 2.5 load事件与DOMContentLoaded事件

```javascript
// 当页面上所有DOM、样式表、脚本、图片都加载完成时触发
window.onload = function() {}
// DOM解析完成后触发
document.addEventListener("DOMContentLoaded", function() {})
```

##### 2.6 阻塞渲染

```
> JS的加载、执行会阻塞DOM树的构建
> CSS资源通过单独的下载线程（浏览器进程控制）加载，不会阻塞DOM树的构建，但是会阻塞页面的渲染
> JS的执行可能会修改CSS，所以需要等待CSS规则树构建完成，因此如果CSS资源还在请求中，后面的JS代码会被阻塞不能立即执行，进而阻塞了DOM树的构建
```

```
script没有defer、async时，会立即加载并执行JS脚本
设置defer、async后在加载JS资源时不会阻塞DOM解析，async在加载完之后执行，defer在DOM解析完成后执行
```

##### 2.8 事件循环

```
JS引擎线程解析代码时，会将同步代码按顺序放入执行栈中执行，如果遇到一些异步代码如setTimeout、DOM事件、异步请求等，会将对应任务添加入对应线程中处理，然后继续执行同步代码，当异步任务满足触发条件时（通过定时器线程、异步http请求线程、事件触发线程等），对应线程会将其回调函数添加到任务队列中，事件触发线程会不断检查任务队列中是否有任务要执行，当同步代码执行完毕后，有则会取出队头任务到执行栈中执行。

宏任务：setTimeout、setInterval
微任务：Promise.then、async/await、queueMicrotask

执行栈执行完所有同步代码后，会先检查微任务队列是否有任务要执行，有则执行，过程中新增的微任务会在此次事件循环中执行，新增的宏任务则放入宏任务队列等待下次事件循环，没有微任务再检查宏任务队列是否有任务要执行，有则取队首任务执行，如此往复。
```

