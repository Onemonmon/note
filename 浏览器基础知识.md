# 面试总结-浏览器

## 1. 浏览器垃圾回收机制

​	JS数据类型分为：原始类型、引用类型，原始类型数据变量名和值都存在栈中，引用类型数据变量名存在栈中，值存在堆中。

​	临时数据：在内存中存在的时间很短，很快就会变得不可访问，如函数作用域或块级作用域中的临时变量

​	持久数据：在内存中存在的时间很长，如全局对象等

​	V8将堆内存分为新生代和老生代两个区域，新生代（小）存放临时数据，老生代存放持久数据，分别由两个垃圾回收器处理

​	新生代垃圾回收器：将新生代区域分为使用区和空闲区，新加入的对象会进入使用区，当使用区快满了就会开始进行垃圾回收，标记使用区中的活动对象，将其复制进空闲区后排序，然后清理使用区中的垃圾数据，最后将使用区和空闲区互换。当一个对象复制到空闲区且此时空闲区的内存占用超过25%，那这个对象会晋升到老生代区域，因为角色反转后如果空闲区内存占比太大，会影响后续的内存分配。

​	老生代垃圾回收器：使用标记清除算法，标记阶段从根对象出发遍历所有子属性，能访达的对象就是活动对象，其他就是垃圾数据；清除阶段就是直接将垃圾数据清理掉。多次标记清楚操作后，会出现大量不连续的内存碎片，需要进行内存整理。

## 2. React Fiber

#### 2.1 浏览器一帧

1. 处理输入事件

 	2. 处理定时器
 	3. 处理Begin Frame（开始帧），即每一帧的事件，包括window.resize、scroll等
 	4. 执行requestAnimation
 	5. 布局
 	6. 绘制
 	7. 执行requestIdleCallback里注册的回调

#### 2.2 执行过程

​	Fiber提供了一种主动让出控制权的机制，首先React向浏览器请求调度，浏览器在一帧的内容执行完成后还有剩余时间，会去判断是否有待执行任务，没有的话就继续执行下一帧，有则将控制权交给React，让其执行任务，当执行完一个任务后若还有剩余时间，且还有待执行任务，则会继续执行下一个任务，没有剩余时间了则会归还控制权。

​	react每次渲染时分：

​		协调阶段：constructor、getDerivedStateFromProps、shouldComponentUpdate、render

​	该阶段可中断，会找出所有节点的变更

​		提交阶段：componentDidMount、getSnapShotBeforeUpdate、componentDidUpdate

​	该阶段不可中断，会执行所有的变更	

## 3. 样式优先级

​	优先级：(A, B, C, D)

​	A. style行内样式的个数

​	B. id选择器的个数

​	C. 类名选择器、伪类的个数

​	D. 标签选择器、伪元素的个数

## 4. BFC

​	块级格式化上下文，是一个独立的渲染区域，规定了内部盒模型如何布局，且其子元素不会影响到外部元素

​	触发属性：

1. overflow: 不是visible; 
  2. float：不是none;
  3. display: flex; 
  4. display: inline-block; 
  5. position: absolute; 
  6. position: fixed;等

​	解决的问题：

1. 计算BFC高度时，浮动元素也会参与计算，可以解决float导致的高度坍塌

 	2. 同一个BFC下的两个相邻元素上下margin会重叠，可以为其中一个元素创建新的BFC解决
 	3. 不会与浮动元素重叠，可以阻止普通文档流被浮动元素遮盖