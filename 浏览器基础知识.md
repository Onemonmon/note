#### 1. 垃圾回收机制

在JS的内存管理中，那些以某种方式可访问到的值被称作是可达的，它们需要保存在内存中，而不可访问的值则需要被回收，JS的垃圾回收机制就是定期找出那些不再被使用的变量，然后释放其内存。

##### 1.1 为什么要回收？

在JS中的数据类型分为基本类型和引用类型，其中（非闭包中的）基本类型在栈内存中，引用类型保存在堆内存中（占空间大且大小不固定），然后在栈内存中保存一个指向该引用类型地址的变量，当对该变量重新赋值时，它与之前指向的对象就没有引用关系了，则该对象变为非活动对象，需要被清理释放内存。

##### 1.2 垃圾回收策略

**标记清除法**

分为标记和清除两个阶段，为所有活动对象打上标记，把没有标记的对象（非活动对象）清除

```0
1. 垃圾收集器在运行时，会给内存中的变量都加上一个标记，假设所有数据都是垃圾，全部标记为0
2. 从各个根对象出发开始遍历，把可访问的变量的标记改为1
3. 销毁并清理所有标记为0的垃圾所占用的内存
4. 把所有内存中的变量的标记重新修改为0，等待下一次垃圾回收
 
缺点：垃圾清理后导致内存碎片化，容易出现许多不连续的空闲内存，分配新对象时需要遍历空闲内存列表，找到合适大小的内存块，可能会出现对象需要分配的内存size过大时，找不到合适的内存块。

如何找到合适的块？
1. First-fit 找到大于等于size的块便立即返回
2. Best-fit 遍历整个空闲列表，返回大于等于size的最小块
3. Worst-fit 遍历整个空闲列表，找到最大的块，然后分成两部分，其中一部分的大小为size返回（形成碎片）
```

**标记整理算法**
针对内存碎片化的缺点，可使用标记整理算法，它在标记阶段和标记清除算法相同，但它不直接清理可回收的垃圾，而是先进行整理，将活动对象向内存的一端移动，最后清理掉末端垃圾数据所占内存。

**引用计数法**

```javascript
1. 声明一个变量a且值是对象obj时，该对象计数器加1
   let a = {name: "zs"} // obj 1
2. 当变量a又赋值给其他变量b时，该对象计数器加1
   let b = a // obj 2
3. 变量a、b的值被覆盖时，计数器减1
   a = 1 // obj 1
   b = 2 // obj 0
4. 计数器为0时对象会被立即回收，所占堆内存释放

缺点：计数器占内存，且无法知道计数器的上限，无法解决循环引用无法回收的问题
```

##### 1.3 V8对垃圾回收的优化

**分代式垃圾回收机制**

```
V8将堆内存分为
  新生代：存放存活时间较短的对象（新生成的对象），通常为1-8M（容量小所以清理频率高）
  老生代：存放存活时间较长的对象（全局对象、经历过多次新生代垃圾回收后还存活的对象），容量较大

新生代垃圾回收
1. 将新生代区域分为使用区和空闲区，新加入的对象会存入使用区，当使用区快被写满时，就执行一次垃圾回收
2. 垃圾回收时会对使用区中的活动对象做标记，标记后将其复制进空闲区并排序
3. 进入垃圾清理阶段，使用区中只剩下非活动对象，对其进行清理
4. 使用区和空闲区进行角色互换

注：当一个对象经过多次复制依然存活时，会被视为存活时间较长的对象，并移动到老生代
注：当一个对象复制到空闲区时，空闲区的空间占用超过25%，该对象会晋升到老生代（角色互换后，若空闲区的空间占用过大，会对后续为对象分配内存时产生影响）

老生代垃圾回收使用标记整理算法
```

#### 2. 进程和线程

##### 2.1 进程和线程的关系

```
> 进程之间相互隔离，一个进程崩溃不会影响其他进程
> 进程之间需要通过IPC（进程间通信）来通信
> 一个进程中可以有多个线程，每个线程并行执行不同的任务
> 一个进程中的任意一个线程崩溃，会导致这个进程崩溃
> 同一个进程下的线程之间，可以直接通信和共享数据
```

##### 2.2 Chrome浏览器进程

```
> 主（浏览器）进程：负责浏览器界面的显示，与用户交互，如地址栏、书签、前进后退刷新按钮，负责协调管理其他进程的工作
> GPU进程：负责渲染浏览器界面
> 网络进程：负责发起和接收网络请求，之前是浏览器进程中的一个模块，后面独立出来成为一个单独的进程
> 插件进程：负责插件的运行，由于插件可能会崩溃，所以需要为每个插件单独分配一个进程来隔离（每个插件各一个）
> 渲染（Renderer）进程：负责标签页内容的渲染（每个tab各一个），只在内存中生成栅格化的数据，不进行绘制，因为它不能在tab没有激活的情况下偷偷渲染页面
```

##### 2.3 渲染进程Renderer

```
渲染进程包含的线程：
> GUI渲染线程：负责页面的渲染，解析HTML、CSS，构建渲染树，布局（重排）、绘制（重绘），GUI渲染线程和JS引擎线程是互斥的，当JS引擎线程执行时，GUI渲染线程会被挂起，其更新任务会被保存到一个队列中，等到JS引擎线程空闲时会立即执行。
> JS引擎线程（内核）：负责解析运行JS代码，会一直等待着任务队列中的任务到来，然后执行，GUI渲染线程和JS引擎线程是互斥的，如果JS的执行时间过长，会导致页面的渲染卡顿。
> 事件触发线程：当JS引擎线程执行到如鼠标点击等事件时，会将任务添加到事件触发线程中，当任务符合触发条件时，该线程会把任务回调添加到事件队列，会开启事件循环机制，不断访问事件队列的头部，等待JS引擎线程空闲后，将队头任务推入执行栈中执行。
> 定时器线程：负责setTimout、setInterval的计时工作，到时间后会将回调放入事件队列中。
> 异步http请求线程：http连接后开启的线程，请求状态改变时，会将回调函数放入事件队列中。
```

##### 2.4 Web Worker

```
> Web Worker为JS提供在后台运行脚本的方法，创建Worker时，JS引擎线程向浏览器申请一个worker子线程（受浏览器进程控制且不能操作DOM），JS引擎线程通过PostMessage API与worker线程通信（参数需要序列化）。
> Web Worker只属于某个tab页，是一个线程，Shared Worker则可以被多个tab页共享，是一个进程。
```

##### 2.5 load事件与DOMContentLoaded事件

```javascript
// 当页面上所有DOM、样式表、脚本、图片都加载完成时触发
window.onload = function() {}
// DOM解析完成后触发
document.addEventListener("DOMContentLoaded", function() {})
```

##### 2.6 阻塞渲染

```
> JS的加载、执行会阻塞DOM树的构建
> CSS资源通过单独的下载线程（浏览器进程控制）加载，不会阻塞DOM树的构建，但是会阻塞页面的渲染
> JS的执行可能会修改CSS，所以需要等待CSS规则树构建完成，因此如果CSS资源还在请求中，后面的JS代码会被阻塞不能立即执行，进而阻塞了DOM树的构建
```

```
script没有defer、async时，会立即加载并执行JS脚本
设置defer、async后在加载JS资源时不会阻塞DOM解析，async在加载完之后执行，defer在DOM解析完成后执行
```

##### 2.8 事件循环

```
JS引擎线程解析代码时，会将同步代码按顺序放入执行栈中执行，如果遇到一些异步代码如setTimeout、DOM事件、异步请求等，会将对应任务添加入对应线程中处理，然后继续执行同步代码，当异步任务满足触发条件时（通过定时器线程、异步http请求线程、事件触发线程等），对应线程会将其回调函数添加到任务队列中，事件触发线程会不断检查任务队列中是否有任务要执行，当同步代码执行完毕后，有则会取出队头任务到执行栈中执行。

宏任务：setTimeout、setInterval
微任务：Promise.then、async/await、queueMicrotask

执行栈执行完所有同步代码后，会先检查微任务队列是否有任务要执行，有则执行，过程中新增的微任务会在此次事件循环中执行，新增的宏任务则放入宏任务队列等待下次事件循环，没有微任务再检查宏任务队列是否有任务要执行，有则取队首任务执行，如此往复。
```

