# 面试总结-手写代码

#### call/apply/bind

```javascript
// call接收参数列表
Function.prototype.myCall = function(context, ...restArgs) {
    if (typeof this !== function) {
        throw Error('xxx')
    }
    !context && (context = window)
    const fnSymbol = Symbol()
    context[fnSymbol] = this
    context[fnSymbol](restArgs)
    delete context[fnSymbol]
}
```

```javascript
// apply接收参数数组
Function.prototype.myApply = function(context, restArgs) {
    if (typeof this !== function) {
        throw Error('xxx')
    }
    !context && (context = window)
    const fnSymbol = Symbol()
    context[fnSymbol] = this
    context[fnSymbol](restArgs)
    delete context[fnSymbol]
}
```

```javascript
// bind接收参数列表
Function.prototype.myBind = function(context, outterArgs) {
    if (typeof this !== function) {
        throw Error('xxx')
    }
    !context && (context = window)
    return (...innerArgs) => {
        this.apply(context, [...outterArgs, ...innerArgs])
    }
}
```

#### new

```javascript
function myNew(constructor, ...restArgs) {
    if (typeof constructor !== 'function') {
        throw Error('xxx')
    }
    // 在内存中创建一个新对象
    const obj = new Object()
    obj.__proto__ = constructor.proptotype
    // 构造函数的this指向该对象
    const res = constructor.apply(obj, restArgs)
    return typeof res === 'object' ? res : obj
}
```

#### Promise

```javascript
const PENDING = 'pending'
const FULFILLED = 'fulfilled'
const REJECTED = 'rejected'
class Promise {
    constructor(executor) {
        this.state = PENDING
        this.value = null
        this.reason = null
        // 缓存then的成功回调函数
        this.onFulfilledCallbacks = []
        // 缓存then的失败回调函数
        this.onRejectedCallbacks = []
        this.resolve = (value) => {
            // 只有PENDING状态下才会被改变状态
            if (this.state === PENDING) {
                this.value = value
                this.state = FULFILLED
        		this.onFulfilledCallbacks.forEach((n) => n());
            }
        }
        this.reject = (error) => {
            // 只有PENDING状态下才会被改变状态
            if (this.state === PENDING) {
                this.value = error
                this.state = REJECTED
        		this.onRejectedCallbacks.forEach((n) => n());
            }
        }
    	// 会立即执行
        executor(this.resolve, this.reject)
    }
    then(onFulfilled, onRejected) {
    	const promise2 = new Promise((resolve, reject) => {
            if (this.state === FULFILLED) {
                queueMicroTask(() => {
                    const x = onFulfilled(this.value)
                	resolvePromise(promise2, x, resolve, reject)
                })
            } else if (this.state === REJECTED) {
                onRejected(this.reason)
            } else if (this.state === PENDING) {
                onFulfilled && this.onFulfilledCallbacks.push(() => onFulfilled(this.value))
                onRejected && this.onRejectedCallbacks.push(() => onRejected(this.reason))
            }
        })
        return promise2
    }
    
    static resolve(value) {
		return new Promise(resolve => resolve(value))
    }
    static reject(reason) {
		return new Promise((resolve, reject) => reject(reason))
    }
    static race(promises) {
        return new Promise((resolve, reject) => {
            for(let i = 0; i < promises.length; i ++) {
                promises[i].then(resolve, reject)
            }
        })
    }
    static all(promises) {
        return new Promise((resolve, reject) => {
            const result = []
            let count = 0
            for(let i = 0; i < promises.length; i ++) {
                promises[i].then(res => {
                    result.push({index: i, result: res})
                	count ++
                    if (count === promises.length) {
                        const newRes = result.sort((a, b) => a.index - b.index).map(n => n.result)
                        resolve(newRes)
                    }
                })
            }
        })
    }
}

function resolvePromise(promise2, x, resolve, reject) {
    if (promise2 === x) {
    	return reject(new TypeError("then不能返回自身"))
    }
    if (x instanceof Promise) {
        // 返回新的Promise时，需判断该Promise的状态
        x.then(resolve, reject)
    } else {
        resolve(x)
    }
}
```

#### Promise并发执行

```javascript
const request = (delay) => () => new Promise(resolve => setTimeout(resolve, delay))

class Scheduler {
    constructor(max) {
        this.maxCount = max
        this.pool = []
    }
    add(task) {
        this.pool.push(task)
    }
    run() {
        if (!this.pool.length) return
        this.pool.shift()().then(() => this.run())
    }
    start() {
        for (let i = 0; i < this.maxCount; i ++) {
            this.run()
        }
    }
}
```

#### Promisify

```javascript
function promisify(fn) {
    // 首先要返回一个函数，该函数执行后返回一个promise
    return function(...args) {
        return new Promise((resolve, reject) => {
            fn.call(this, ...args, (err, data) => {
                err ? reject(err) : resolve(data)
            })
        })
    }
}
```

#### reduce

```javascript
// array.reduce(function(total, currentValue, currentIndex, arr), initialValue)
Array.prototype.reduce = function (callback, initValue) {
	const hasInitValue = initValue !== undefined && initValue !== null;
  	let total = hasInitValue ? initValue : arr[0];
  	for (let i = hasInitValue ? 0 : 1; i < this.length; i++) {
    	total = callback(total, this[i], i, this);
  	}
  	return total;
};
```

#### 防抖

```javascript
function debounce(fn, delay) {
    let timer = null
    return function() {
        timer && clearTimeout(timer)
        timer = setTimeout(() => {
            fn.call(this, ...arguments)
        }, delay)
    }
}
```

#### 节流

```javascript
function throttle(fn, delay) {
    let timer = null
    let flag = false
   	return function() {
        if (flag) {
            return
        }
        flag = true
        timer = setTimeout(() => {
            flag = false
            timer && clearTimeout(timer)
            fn.call(this, ...arguments)
        }, delay)
    }
}
```

#### 深拷贝

```javascript
function deepClone(obj = {}, map = new Map()) {
    if (typeof obj !== 'object') {
    	return obj
    }
    if ([Date, RegExp].includes(obj.constructor)) {
        return new obj.constructor(obj)
    }
    // 考虑循环引用
    if (map.get(obj)) {
        return map.get(obj)
    }
    const cloneTarget = Object.prototype.toString(obj) === '[object Array]' ? [] : {}
    map.set(obj, cloneTarget)
	for(let key in obj) {
        cloneTarget[key] = deepClone(obj[key], map)
    }
    return cloneTarget
}
```

#### instanceof

```javascript
function myInstanceof(Case, Constructor) {
    if (typeof Case !== 'object' && typeof Case !== 'function' || Case === null) return false
    let caseProto = Object.getPrototypeOf(Case)
    while(1) {
        if (caseProto === Constructor.prototype) {
            return true
        }
        if (caseProto === null) {
            return false
        }
        caseProto = Object.getPrototypeOf(caseProto)
    }
}
```

#### 函数柯里化

```javascript
// JavaScript中toValue和toString的自动调用？
// 对象在参与运算时，会先调用valueOf，尝试把对象转换成基本数据类型，如果没有转换成功，则会再次调用toString，如果还不能转换成基本数据类型，就会报错。

function add() {}
add.valueOf = function() {
    console.log("valueOf")
    // 此处返回基本数据类型则不会再调用toString
    // return 10
    return add
}
add.toString = function() { 
	console.log("toString")
    return 10
}
add + 1 // valueOf toString 11
```

```javascript
// add(1, 2, 3)(4)(5, 6).sumOf()
function add(...args) {
    // 保存所有参数，先不进行加法
    const allArgs = args
    function innerAdd(...newArgs) {
        allArgs.push(...newArgs)
        return innerAdd
    }
    // 调用sumOf的时候将所有参数相加
    innerAdd.sumOf = function() {
        return allArgs.reduce((total, n) => total += n)
    }
    return innerAdd
}
```

```javascript
// curry(add)(1)(2, 3)
function add(a, b, c) {
    return a + b + c
}
function curry(fn, ...args) {
    // 需要柯里化的函数的入参个数（不包括默认参数）
    const length = fn.length
    return function() {
        // 拼接每次的入参
        const innerArgs = [...args, ...arguments]
        // 参数数量不够则递归调用，继续拼接
        if (innerArgs.length < length) {
            return curry.call(this, fn, ...innerArgs)
        }
        // 参数数量满足，调用函数返回结果
        return fn.apply(this, innerArgs)
    }
}
```

