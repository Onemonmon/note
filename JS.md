### 1. 数据类型

```
基本类型：String、Number、Boolean、Symbol、Null、Undefined、Bigint
变量名和值都保存在栈内存中

引用类型：Object、Array、Function、Date、RegExp
变量名和值的存储地址保存在栈内容中，值保存在堆内存中
```

```
Symbol用于生成一个唯一值，不能使用new Symbol()
Symbol() !== Symbol()
Symbol.for('name') === Symbol.for('name')
Symbol.for(key)方法会将创建的symbol放入全局的symbol注册表中，并且使用Symbol.for(key)时，不会每次都创建新的symbol，而是会先判断给定的key是否在注册表中，有则直接返回，否则再重新创建
```

```
Bigint用于表示一个任意精度的整数，不能使用new Bigint()
Bigint数据需添加后缀n（12n）
12n == 12
12n !== 12
如果与Number混合运算则需要类型转换
```

```
检测数据类型的方法：
> typeof
  能快速区分基本数据类型，但无法区分Object、Array、Null，都返回Object
> instanceof
  能区分Object、Array、Function，适用于判断自定义类实例，但无法判断基本数据类型
> Object.prototype.toString.call()
  精准判断
```

### 2. 变量声明

```
> var
  没有块级作用域，可以跨域访问
  可以先使用后声明（存在变量提升：JS执行前会将var、function的变量提前声明）
  可以重复声明，后面重复声明的变量会覆盖之前的
  var定义的全局变量会绑定在顶层对象window上
> let
  先定义后使用（存在暂时性死区：let的块级作用域开始，到初始化的位置），在暂时性死区中使用变量会报错
  不可重复声明
> const
  不可重复声明
  声明时必须初始化
  声明的常量不可重新赋值，但其只保证了变量名指向的地址不变，不能保证该地址保存的数据不变
```

### 3. 作用域与作用域链

```
作用域是代码运行过程中某些变量、函数的访问范围，用于隔离变量
> 全局作用域
  在代码的任何位置都能访问到的变量具有全局作用域
  包括：最外层函数、最外层变量、未定义就直接赋值的变量、window对象及属性
> 函数作用域
  在函数内部声明的变量拥有函数作用域，外层作用域无法访问内层作用域的变量
> 块级作用域
  ES6新增，通过let、const声明变量拥有块级作用域
```

```
作用域链：使用变量时现在当前函数作用域中取值，如果没有找到，则会向上级作用域（若是函数，则要到创建这个函数的作用域去找）查找，直到查到全局作用域
```

### 4. 闭包

```
闭包是指有权访问另一个函数中的变量的函数，因为变量被引用，所以另一个函数执行结束后，变量不会被回收，因此可以用来封装一个私有变量。
形成条件：函数的嵌套、内部函数使用了外部函数的局部变量
作用：保护函数的私有变量不受外部干扰，可以实现函数内部方法和变量的私有化
闭包函数使用后应该及时清除引用（置为null），不正当的使用闭包会造成内存泄漏
```

### 5. this指向

```
普通函数执行时，this指向window
当函数作为对象的方法执行时，this指向该对象
使用new调用时，this指向内部创建的对象
箭头函数的this会继承自定义时的外层函数的this，如果没有外层函数则指向window
DOM事件函数的this指向绑定事件的DOM元素
call、apply、bind动态绑定this
```

### 6. 原型与原型链

```
每个class和（非箭头）函数都有prototype原型对象，它有一个默认的constructor属性，用于记录实例是由哪个构造函数创建的
每个对象都有__proto__属性，它是一个对象，指向上层对象的原型对象，有constructor、__proto__两个属性
```

```javascript
Person.prototype.constructor === Person
p.__proto__ === Person.prototype
Person.prototype.__proto__ === Object.prototype
Object.prototype.__proto__ === null
```

### 7. new 的实现机制

```javascript
function myNew(Constructor, ...args) {
    if (typeof Constructor !== 'function') {
        throw Error('xxx')
    }
    // 先创建一个对象，并将其原型指向构造函数的原型对象
    const obj = Object.create(Constructor.prototype)
    // 绑定构造函数的this为创建的对象
    const res = Constructor.call(obj, ...args)
   	// 如果构造函数的返回值是对象，则返回该对象，否则返回创建的对象
    return typeof res === 'object' ? res : obj
}
```

### 8. 垃圾回收机制

```
在JS的内存管理中，那些以某种方式可访问到的值被称作是可达的，它们需要保存在内存中，而不可访问的值则需要被回收，JS的垃圾回收机制就是定期找出那些不再被使用的变量，然后释放其内存。
```

```
> 标记清除法
  大致流程：
  垃圾收集器在运行时，会给内存中的变量都加上一个标记，假设所有数据都是垃圾，全部标记为0
  从各个根对象出发开始遍历，把可访问的变量的标记改为1
  销毁并清理所有标记为0的垃圾所占用的内存
  把所有内存中的变量的标记重新修改为0，等待下一次垃圾回收
  缺点：
  垃圾清理后导致内存碎片化，容易出现许多不连续的空闲内存，分配新对象时需要遍历空闲内存列表，找到合适大小的内存块，可能会出现对象需要分配的内存过大时，找不到合适的内存块。
  针对内存碎片化的缺点，可使用给标记整理算法，它在标记阶段和标记清除算法相同，但它不直接清理可回收的垃圾，而是先进行整理，将不需要清理的数据向内存的一端移动，最后清理掉末端垃圾数据所占内存。
> 引用计数法
  变量被赋值或者变量赋值给另一个变量时，计数器加1，变量值被覆盖时，计数器减1，计数器为0时被回收
  缺点：计数器占内存，且无法知道计数器的上限，无法解决循环引用无法回收的问题
```

```
V8对垃圾回收的优化（分代式垃圾回收机制）
V8将堆内存分为
  新生代：存放存活时间较短的对象（新生成的对象），通常为1-8M（容量小所以清理频率高）
  老生代：存放存活时间较长的对象（全局对象、经历过多次新生代垃圾回收后还存活的对象），容量较大
新生代垃圾回收：
  将新生代区域分为使用区和空闲区，新加入的对象会存入使用区，当使用区快被写满时，就执行一次垃圾清理
  新生代垃圾回收器会对使用区中的活动对象做标记，标记后将其复制进空闲区并排序，然后将非活动对象清理
  将使用区和空闲区进行互换
  注：当一个对象经过多次复制依然存活时，会被视为存活时间较长的对象，并移动到老生代
  注：当一个对象复制到空闲区，空闲区的空间占用超过25%时，该对象会晋升到老生代（角色互换后，若空闲区的空间占用过大，会对后续为对象分配内存时产生影响）
老生代垃圾回收：
  使用标记整理算法
```

### 9. EventLoop 事件循环

```
JS是单线程的，同一时刻只能有一个代码段在主线程（浏览器提供的JS引擎线程）的执行栈上执行，而异步任务则是在浏览器（多线程）提供的其他线程上执行，如setTimeout（定时器线程）、网络请求（HTTP线程）等。

JS解析代码的时候会将同步代码按顺序放入执行栈中，依次执行栈中的函数，如果遇到一些异步代码，浏览器会将这些异步代码放到对应线程中执行，且不阻塞主线程，当异步代码执行完成后，会将它的回调函数放入任务队列中等待执行，当执行栈中的代码执行完毕后，就会检查任务队列中是否有任务要执行，有则会将该任务放到执行栈中执行，如果期间又遇到异步任务则再交给其他线程去执行，如此循环。

浏览器的任务队列分为宏任务队列和微任务对列，分别处理宏任务和微任务
宏任务：setTimeout、setInterval、setImmediate、I/O（文件读取、网络请求）
有明确的异步任务需要执行和回调，需要浏览器提供的其他线程支持
微任务：Promise.then、async/await、queueMicrotask、process.nextTick
没有明确的异步任务需要执行，只有回调（改变代码执行顺序），有也只是在微任务中嵌套了宏任务，不需要浏览器提供的其他线程支持

具体流程为：
执行栈执行完所有同步代码后，会先检查微任务队列是否有任务要执行，有则执行，过程中新增的微任务会在此次事件循环中执行，新增的宏任务则放入宏任务队列等待下次事件循环，没有微任务再检查宏任务队列是否有任务要执行，有则取队首任务执行，如此往复。
```

```
定时器误差：当浏览器定时器线程完成计时后，触发定时器事件，将回调存入宏任务队列，等待主线程空闲后执行，如果此时主线程还在执行同步代码或者微任务，那就导致定时器回调无法按时执行而导致误差。
```

```
NodeJS中的事件循环分为6个阶段：
> timers阶段：执行setTimeout、setInterval回调
> pending callbacks阶段：执行上一轮循环未执行的I/O回调
> idle，prepare阶段
> poll阶段：执行大部分I/O回调，计算阻塞时间
  当poll阶段的队列不为空，则会遍历队列同步执行，直到清空队列或执行时间达到系统限制
  当poll阶段的队列为空，且有timers到期，则会进入到timers阶段
  当poll阶段的队列为空，且有setImmediate时，进入check阶段
  当poll阶段的队列为空，且没有setImmediate时，会阻塞在该阶段等待回调加入队列并执行
> check阶段：执行setImmediate回调
> close callback：执行一些关闭的回调

每个阶段结束后都会执行中间队列，先执行nextTick队列，再执行Promise队列
```

### 10.  cookie、localStorage、sessionStorage

```
1. cookie可设置失效时间，未设置时默认关闭浏览器后清除；localStorage只能代码或手动清除；sessionStorage在关闭tab页或浏览器时清除
2. cookie可存放4KB，localStorage、sessionStorage可存放5MB
3. cookie会自动携带在http请求头中，localStorage、sessionStorage不参与和服务器的通信
```

### 11. 跨域解决方案

```
同源：协议、域名、端口相同
跨域：当前网站试图执行其他不同源网站的脚本时，由于浏览器的同源策略而无法访问
```

```
CORS跨域资源共享
服务端设置Access-Control-Allow-origin: 允许跨域访问的域名/*
此时发送的请求会分为
> 简单请求：
  请求方法为Head、Get、Post
  content-type为text/plain、multiple/form-data、application/x-www-form-urlencoded
> 复杂请求：
  发送复杂请求前，浏览器会先发送OPTION预检请求，用于判读服务器是否允许跨域，服务器接收到OPTION请求后，会检查Origin、Access-Control-Request-Method、Access-Control-Allow-Header字段，决定是否允许跨域
```

```
Node中间件代理
原理：同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略
本地使用webpack.devServer中的proxy配置
http-proxy-middleware中间件
```

```
Nginx反向代理
通过Nginx配置一个代理服务器（同域名不同端口），设置location.proxy_pass
```

